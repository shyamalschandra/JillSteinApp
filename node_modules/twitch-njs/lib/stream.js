'use strict';

const https = require('https');
const consts = require('../consts');
const pagedRequest = require('./util').pagedRequest;

/**
 * This is the root aggregate class for all twitch related API calls.
 */
class TwitchStream {
    /**
     * Creates a new instance for the specified stream.
     *
     * @param {string} name the target stream's name, case-insensitive.
     */
    constructor(name) {
        if (typeof(name) != 'string')
            throw new Error("Provided name must be a string.");
        else if (!name)
            throw new Error("A twitch channel name must be provided.");

        this.name = name;
    }

    /**
     * Gathers all basic metadata about the given channel.
     *
     * @param {function} callback the callback of this asynchronous call with two arguments. The first
     * will contain an error object iff an error occurred, whereas in case of success the result
     * of this call will be provided in the second argument.
     */
    info(callback) {
        let url = consts.APIURL + 'channels/' + this.name;
        https.get(url, function (res) {
            let body = '';
            res.on('error', function (err) {
                callback.call(this, err, null);
            });
            res.on('data', function (data) {
                body += data;
            });
            res.on('end', function () {
                let result = JSON.parse(body);
                callback.call(this, null, result);
            });
        });
    }

    /**
     * Gathers the stream's metadata if it is online.
     *
     * @param {function} callback the callback of this asynchronous call with two arguments. The first
     * will contain an error object iff an error occurred, whereas in case of success the result
     * of this call will be provided in the second argument.
     */
    streams(callback) {
        let url = consts.APIURL + 'streams/' + this.name;
        https.get(url, function (res) {
            let body = '';
            res.on('error', function (err) {
                callback.call(this, err, null);
            });
            res.on('data', function (data) {
                body += data;
            });
            res.on('end', function () {
                let result = JSON.parse(body);
                callback.call(this, null, result);
            });
        });
    }

    /**
     * Gets a list of all followers of this channel in order of the date they started following (in
     * descending order).
     *
     * @param {function} callback the callback of this asynchronous call with two arguments. The first
     * will contain an error object iff an error occurred, whereas in case of success the result
     * of this call will be provided in the second argument.
     * @param {int?} limit the maximum number of follows to read per callback; must be greater than zero. Defaults
     * to 25.
     * @param {int?} offset the offset at which to start; must be non-negative. Defaults to 0.
	 * @param {string?} direction either DESC or ASC; defaults to DESC.
     */
	follows(callback, limit, offset, direction) {
        if (!limit) limit = 25;
        if (!offset) offset = 0;
		if (!direction) direction = 'DESC';

		let url = `${consts.APIURL}channels/${this.name}/follows?direction=${direction}&limit=${limit}&offset=${offset}`;
		pagedRequest(url, callback, function (page) {
			page.follows = page.follows.map(function (x) {
				x.stream = new TwitchStream(x.user.name);
				return x;
			});
			return page;
		});
    }

	videos(callback, limit, offset) {
		if (!limit) limit = 25;
        if (!offset) offset = 0;

		let url = `${consts.APIURL}channels/${this.name}/videos?limit=${limit}&offset=${offset}`;
		pagedRequest(url, callback);
	}
}

module.exports = TwitchStream;
