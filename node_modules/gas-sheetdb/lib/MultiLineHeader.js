/**
 * WIL.Spreadsheet.RowHeader class
 * @fileoverview includes WIL.Spreadsheet.RowHeader Class.
 */

var assert = require('./assert');

/**
 * Constractor.
 * @param {Object} TABLE
 * @param {Array.<number>} args Columns in sheet to create with.
 * @return {Object} table itself for chaining.
 */
function MultiLineHeader(TABLE, dir, args) {

  // get header data from spreadsheet into local array.
  this.sheetData = loadSheetData_(TABLE, dir, args);

  this.headerIndex = setupIndex_(this.sheetData);
}

/**
 * @param {string|Array.<string>} headerIndex
 * @return {number}
 */
MultiLineHeader.prototype.getIndex = function(indexStr) {

  var istr, iarray;

  if (typeof indexStr === 'number') {
    return indexStr;
  }

  if (typeof indexStr === 'string') {
    istr = indexStr;
    iarray = indexStr.split('.');

  } else if (Object.prototype.toString.call(indexStr) === '[object Array]') {
    istr = /** @type {Array.<string>} */ (indexStr).join('.');
    iarray = indexStr;

  } else {
    return -1;  // should throw error.
  }

  for (var i = iarray.length; i < this.sheetData.length; i++) {
    iarray.push('');
  }
  istr = iarray.join('.');

  if (this.headerIndex[istr]) {
    return this.headerIndex[istr][this.headerIndex[istr].length - 1];
  }

  return -1;    // not found.
};


function loadSheetData_(TABLE, dir, lines) {    // jshint ignore:line
                                                // ~ used before it was defined.
  var numLines = lines.length;
  assert(numLines >= 1, "Table:Header: missing col/row.");
  assert((dir === 'row') || (dir === 'col'), "Table:Header: Invalid direction.");

  var sheetData = [], lineRange, lineLength;

  for (var il = 0; il < numLines; il++) {

    sheetData[il] = [];

    lineRange = (dir === 'row') ?
                TABLE.sheet_.getRange(lines[il], TABLE.tCol_, 1, TABLE.numColumns_) :
                TABLE.sheet_.getRange(TABLE.tRow_, lines[il], TABLE.numRows_, 1);

    lineRange = lineRange.getValues();

    lineLength = (dir === 'row') ? TABLE.numColumns_ : TABLE.numRows_;

    for (var ic = 0; ic < lineLength; ic++) {

      var cell = (dir === 'row') ? lineRange[0][ic] : lineRange[ic][0];

      switch (typeof cell) {

        case 'string':
          var idx = cell.indexOf('.');
          if (idx >= 0) {
            cell = cell.substring(0, idx);
          }
          cell = cell.replace(/\n/g, '');
          break;

        case 'number':
          cell = cell.toString(10);
          break;

        default:
          // Date object.
          // todo: Date object should be changed to yyyy/mm/dd format.
          cell = cell.toString();
          break;
      }

      sheetData[il][ic] = cell;
    }
  }
  return sheetData;
}


function setupIndex_(sheetData) {   // jshint ignore:line
                                    // ~ used before it was defined.
  var lastLine = sheetData.length - 1,
      lineLength = sheetData[0].length,
      headerIndex = {};

  // set indexString as default. [ '', '', '' ]
  var indexString = [];
  for (var i = 0; i < lastLine; i++) {
    indexString.push('');
  }

  var index, line;

  for (index = 0; index < lineLength; index++) {

    // get index strings ex. [ 'Expence', 'Sales', NOT_SET_HERE ]
    for (line = 0; line < lastLine; line++) {

      if (sheetData[line][index] !== '') {
        indexString[line] = sheetData[line][index];

        // When parent index changes, children should be cleared.
        for (var n = line + 1; n < lastLine; n++) {
          indexString[n] = '';
        }
      }
    }
    indexString[lastLine] = sheetData[lastLine][index];

    // add index into this.rowIndex_.
    var istr = indexString.join('.');
    if (typeof headerIndex[istr] === 'undefined') {
      headerIndex[istr] = [];
    }
    headerIndex[istr].push(index + 1);   // index starts 0, row/col starts 1.
  }

  return headerIndex;
}


module.exports = MultiLineHeader;
