'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HTTPError = exports.Session = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _path = require('path');

var _eventPromise = require('event-promise');

var _eventPromise2 = _interopRequireDefault(_eventPromise);

var _streamConcatPromise = require('stream-concat-promise');

var _streamConcatPromise2 = _interopRequireDefault(_streamConcatPromise);

var _timeoutAsPromise = require('timeout-as-promise');

var _timeoutAsPromise2 = _interopRequireDefault(_timeoutAsPromise);

var _strto = require('strto');

var _strto2 = _interopRequireDefault(_strto);

var _httpAuth = require('./http-auth.js');

var httpAuth = _interopRequireWildcard(_httpAuth);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

const default_agent = () => new _https2.default.Agent({ keepAlive: true, maxSockets: 1 });

class Auth {

  constructor(session, client_id, client_secret, refresh_token) {
    this.client_id = null;
    this.client_secret = null;
    this.refresh_token = null;
    this._session = null;
    this._promise_for_token = null;

    this._session = session;
    this.client_id = client_id;
    this.client_secret = client_secret;
    this.refresh_token = refresh_token;
  }

  // How close to its scheduled expiration do we continue to use a token?


  get_token() {
    var _this = this;

    if (this._promise_for_token === null) {
      this._promise_for_token = this._request_token().then(token => {

        /* Throw out the token later */
        _asyncToGenerator(function* () {
          yield (0, _timeoutAsPromise2.default)(1000 * (token.expires_in - Auth.token_expiry_margin));
          yield _this._discard_token();
          console.log('Successfully discarded access token.');
        })().catch(function (err) {
          console.error('Failed to discard access token!');
          console.error(err.toString());
        });

        return token.access_token;
      });
    }
    return this._promise_for_token;
  }

  _request_token() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      let [status_code, headers, res_body] = yield _this2._session._request_base('POST', 'www.reddit.com', '/api/v1/access_token', undefined, { 'Authorization': httpAuth.basic(_this2.client_id, _this2.client_secret) }, { grant_type: 'refresh_token', refresh_token: _this2.refresh_token }, undefined);

      if (status_code != 200) {
        throw new HTTPError(status_code, res_body);
      }

      return JSON.parse(res_body);
    })();
  }

  _discard_token() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      if (_this3._promise_for_token === null) {
        return;
      }
      let token = yield _this3._promise_for_token;
      _this3._promise_for_token = null;

      let [status_code, headers, res_body] = yield _this3._session._request_base('POST', 'www.reddit.com', '/api/v1/revoke_token', undefined, { 'Authorization': httpAuth.basic(_this3.client_id, _this3.client_secret) }, { token, token_type_hint: 'access_token' }, undefined);

      if (status_code != 204) {
        throw new HTTPError(status_code, res_body);
      }
    })();
  }

  close() {
    return _discard_token();
  }
}

Auth.token_expiry_margin = 10;
class Session {
  constructor({ http_agent = default_agent(), user_agent, auth }) {
    this._agent = null;
    this.user_agent = null;
    this._auth = null;
    this._ratelimit_ready = null;

    let self = this;

    this._agent = http_agent;
    this.user_agent = user_agent;

    this._auth = new Auth(this, auth.client_id, auth.client_secret, auth.refresh_token);
  }

  _request_base(method, host, pathname, query, headers, body, progress_cb) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      let final_progress_cb = progress_cb || function () {
        return undefined;
      };

      let final_headers = _extends({
        'Host': host,
        'User-Agent': _this4.user_agent
      }, headers);

      let hasBody = ['POST', 'PUT', 'PATCH'].includes(method);

      if (hasBody) {
        if (!Buffer.isBuffer(body)) {
          body = new Buffer(_querystring2.default.stringify(_extends({
            api_type: 'json'
          }, body)));
          final_headers['Content-Type'] = 'application/x-www-form-urlencoded';
        }
        final_headers['Content-Length'] = body.length;
      }

      query = _extends({
        'raw_json': '1'
      }, query);

      let req = _https2.default.request({
        agent: _this4._agent,
        method,
        host,
        path: _url2.default.format({ pathname, query }),
        headers: final_headers
      });
      req.end(body);

      let response = yield (0, _eventPromise2.default)(req, 'response'),
          resBody = yield (0, _streamConcatPromise2.default)(response);

      if ([502, 503, 504, 522].includes(response.statusCode)) {
        return _this4._request_base(method, host, pathname, query, headers, body, progress_cb);
      }

      return [response.statusCode, response.headers, resBody];
    })();
  }

  request({ method = 'GET', pathname, query = {}, headers = {}, body }, progress_cb) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      yield _this5._ratelimit_ready;

      let final_headers = _extends({
        'Authorization': httpAuth.bearer((yield _this5._auth.get_token()))
      }, headers);

      let [statusCode, resHeaders, resBody] = yield _this5._request_base(method, 'oauth.reddit.com', pathname, query, final_headers, body, progress_cb);

      let ratelimit_remaining = Math.trunc(_strto2.default.finitefloat(resHeaders['x-ratelimit-remaining'], -1)),
          ratelimit_reset = Math.trunc(_strto2.default.finitefloat(resHeaders['x-ratelimit-reset'], -1));

      if (ratelimit_remaining < 0 || ratelimit_reset < 0) {
        throw new TypeError('Failed to read ratelimit information');
      }

      if (ratelimit_remaining === 0) {
        _this5._ratelimit_ready = (0, _timeoutAsPromise2.default)(1000 * ratelimit_reset);
      }

      return JSON.parse(resBody);
    })();
  }

  close() {
    return this._auth.close();
  }
}

exports.Session = Session;
class HTTPError extends Error {
  constructor(status, message) {
    super(`${ status }: ${ message }`);
  }
}
exports.HTTPError = HTTPError;
//# sourceMappingURL=main.js.map
